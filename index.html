<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INE V28 - Corrector de Nombres</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- OpenCV.js para el procesamiento de imagen -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <!-- Tesseract.js para OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- Fuse.js para la búsqueda difusa y corrección -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        /* Estilos personalizados para las etiquetas de validación */
        .tag-correct {
            background-color: #d1fae5; color: #047857; border: 1px solid #10b981;
            padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold;
        }
        .tag-warning {
            background-color: #fef3c7; color: #b45309; border: 1px solid #f59e0b;
            padding: 2px 6px; border-radius: 4px; font-size: 10px;
        }
        .tag-error {
            background-color: #fee2e2; color: #b91c1c; border: 1px solid #ef4444;
            padding: 2px 6px; border-radius: 4px; font-size: 10px; text-decoration: line-through;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans p-4">

    <div class="max-w-5xl mx-auto">
        
        <!-- Encabezado -->
        <div class="flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-xl border border-gray-700 shadow-lg">
            <h1 class="text-xl font-bold text-emerald-400 flex items-center gap-2">
                <i class="fas fa-check-double"></i> Extractor de texto de imagen por Edwin v28 (sube ine centrada)
            </h1>
            <div id="status" class="px-3 py-1 bg-gray-700 rounded-full text-xs font-mono">Cargando...</div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <!-- COLUMNA IZQUIERDA: VISUAL -->
            <div class="space-y-4">
                <!-- Input de archivo -->
                <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                    <input type="file" id="fileInput" accept="image/*" disabled class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700 cursor-pointer"/>
                </div>
                <!-- Canvas de visualización -->
                <div id="visual-area" class="hidden">
                    <canvas id="canvasOutput" class="w-full rounded border border-gray-600"></canvas>
                </div>
            </div>

            <!-- COLUMNA DERECHA: DATOS Y LOGS -->
            <div class="space-y-4">
                <div class="bg-white text-gray-900 p-6 rounded-xl shadow-2xl border-t-4 border-emerald-500 relative">
                    
                    <!-- Loader overlay -->
                    <div id="loader" class="hidden absolute inset-0 bg-white/95 z-20 flex flex-col items-center justify-center rounded-xl">
                        <i class="fas fa-sync fa-spin text-4xl text-emerald-500 mb-2"></i>
                        <span class="text-xs font-bold text-emerald-600 uppercase">Verificando Nombres...</span>
                    </div>

                    <h2 class="text-lg font-bold mb-4 border-b pb-2">Datos Validados</h2>
                    
                    <form onsubmit="event.preventDefault(); alert('Datos Correctos');">
                        
                        <!-- Campo NOMBRE -->
                        <div class="mb-4">
                            <label class="block text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-1">Nombre (Corregido)</label>
                            <input type="text" id="nombre" class="w-full text-lg font-bold p-2 bg-emerald-50 border-l-4 border-emerald-500 focus:bg-white outline-none uppercase text-slate-900" placeholder="...">
                            <!-- Aquí se insertan las etiquetas de validación -->
                            <div id="name-feedback" class="mt-2 flex flex-wrap gap-1"></div>
                        </div>

                        <!-- Campo CURP -->
                        <div class="mb-4">
                            <label class="block text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-1">CURP</label>
                            <div class="relative">
                                <input type="text" id="curp" maxlength="18" class="w-full font-mono text-xl p-2 bg-gray-100 border-l-4 border-emerald-500 outline-none uppercase tracking-widest text-slate-800" placeholder="------------------">
                                <i id="curp-icon" class="fas fa-check-circle absolute right-3 top-3 text-emerald-500 opacity-0"></i>
                            </div>
                        </div>
                    </form>
                </div>

                <!-- Log de Consola -->
                <div class="bg-black p-3 rounded border border-gray-700 h-48 overflow-y-auto font-mono text-[10px]">
                    <p class="text-gray-500 border-b border-gray-800 mb-2 pb-1">LOG DE CORRECCIÓN:</p>
                    <div id="log-box" class="space-y-1 text-gray-400">Esperando imagen...</div>
                </div>
            </div>
        </div>
        <img id="imgSrc" class="hidden">
    </div>

    <script>
        // --- BASE DE DATOS DE NOMBRES ---
        // Esta lista ayuda a corregir errores tipográficos comunes del OCR.
        const COMMON_NAMES = [
            "GARCIA", "MARTINEZ", "LOPEZ", "GONZALEZ", "RODRIGUEZ", "HERNANDEZ", "PEREZ", "SANCHEZ", "RAMIREZ", "FLORES",
            "GOMEZ", "TORRES", "DIAZ", "VASQUEZ", "CRUZ", "MORALES", "GUTIERREZ", "REYES", "RUIZ", "JIMENEZ",
            "MENDOZA", "AGUILAR", "ORTIZ", "ALVAREZ", "CASTILLO", "ROMERO", "MORENO", "CHAVEZ", "RIVERA", "RAMOS",
            "HERRERA", "MEDINA", "DOMINGUEZ", "VELAZQUEZ", "VEGA", "ESPINOZA", "BLANCO", "NAVARRO", "CORTES", "GUERRERO",
            "MUNOZ", "ALVARADO", "DELGADO", "ESTRADA", "CONTRERAS", "SALAZAR", "AYALA", "VALENZUELA", "CERVANTES", "ROJAS",
            "PUGA", "TOVAR", "CALDERON", "SALAS", "VALDEZ", "PACHECO", "RANGEL", "VALENCIA", "NAVA", "MEJIA",
            "SANTOS", "SOTO", "MONTES", "PENA", "ROBLES", "ACOSTA", "FUENTES", "MOLINA", "ARROYO", "CAMPOS",
            // NOMBRES DE PILA
            "JUAN", "JOSE", "LUIS", "MARIA", "GUADALUPE", "FRANCISCO", "ANTONIO", "JESUS", "MIGUEL", "ANGEL",
            "PEDRO", "ALEJANDRO", "MANUEL", "MARGARITA", "CARLOS", "ROBERTO", "FERNANDO", "DANIEL", "JORGE", "RICARDO",
            "EDWIN", "ALEXIS", "EDUARDO", "JAVIER", "RAFAEL", "MARTIN", "RAUL", "DAVID", "JOSEFINA", "VERONICA",
            "ALBERTO", "ENRIQUE", "GERARDO", "MARIO", "ARMANDO", "SERGIO", "GILBERTO", "GABRIEL", "ANDRES", "ADRIAN",
            "HECTOR", "SALVADOR", "FELIPE", "RUBEN", "SILVIA", "ELIZABETH", "ALICIA", "BEATRIZ", "YOLANDA", "LETICIA",
            "MARTHA", "TERESA", "GLORIA", "ROSA", "ANA", "ADRIANA", "GABRIELA", "PATRICIA", "ALEJANDRA", "CLAUDIA",
            "SOFIA", "CAMILA", "VALERIA", "XIMENA", "VICTORIA", "DANIELA", "FERNANDA", "ANDREA", "LUCIA", "VALENTINA",
            "SANTIAGO", "MATEO", "SEBASTIAN", "LEONARDO", "MATIAS", "EMILIANO", "DIEGO", "SAMUEL", "IKER", "GABRIEL",
            "ALAN", "EMMANUEL", "OMAR", "OSCAR", "HUGO", "EDGAR", "JULIO", "CESAR", "MARCO", "IVAN"
        ];

        // Configuración de Fuse.js para encontrar nombres similares
        const fuse = new Fuse(COMMON_NAMES, {
            includeScore: true,
            threshold: 0.35, // Nivel de tolerancia (0.0 es exacto, 1.0 es cualquier cosa)
            minMatchCharLength: 3
        });

        let cvReady = false;

        // Función para escribir en el log de pantalla
        function log(msg, type='info') {
            const el = document.getElementById('log-box');
            let color = type === 'ok' ? 'text-emerald-400' : (type === 'warn' ? 'text-yellow-400' : 'text-gray-400');
            el.innerHTML += `<div class="${color}">> ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        // Callback cuando OpenCV termina de cargar
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('status').innerText = "LISTO";
            document.getElementById('status').className = "px-3 py-1 bg-emerald-600 text-white rounded-full text-xs font-bold";
            document.getElementById('fileInput').disabled = false;
        }

        // Evento al subir imagen
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if(!e.target.files[0]) return;
            
            // Reiniciar interfaz
            document.getElementById('visual-area').classList.remove('hidden');
            document.getElementById('loader').classList.remove('hidden');
            document.getElementById('nombre').value = '';
            document.getElementById('curp').value = '';
            document.getElementById('name-feedback').innerHTML = '';
            document.getElementById('log-box').innerHTML = '';
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = document.getElementById('imgSrc');
                img.src = ev.target.result;
                img.onload = () => processImage(img);
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        // --- 1. PROCESAMIENTO VISUAL (OpenCV) ---
        function processImage(imgElement) {
            if(!cvReady) return;

            try {
                let src = cv.imread(imgElement);
                
                // 1. Detectar bordes y enderezar la tarjeta (Warp Perspective)
                let cardMat = detectAndWarp(src);
                
                // 2. Recortar el área derecha donde están los datos
                // Coordenadas ajustadas para INE estándar (1000x630)
                let rectData = new cv.Rect(270, 100, 700, 500);
                
                // Validación de seguridad para no salirnos de la imagen
                if (rectData.x + rectData.width > cardMat.cols) rectData.width = cardMat.cols - rectData.x;
                if (rectData.y + rectData.height > cardMat.rows) rectData.height = cardMat.rows - rectData.y;
                
                let dataMat = cardMat.roi(rectData);

                // 3. Mejorar la imagen (Escala de Grises + CLAHE)
                // No usamos binarización agresiva para no romper letras delgadas
                let gray = new cv.Mat();
                cv.cvtColor(dataMat, gray, cv.COLOR_RGBA2GRAY);
                let clahe = new cv.CLAHE(3.0, new cv.Size(8, 8));
                clahe.apply(gray, gray);
                
                // Upscale x2 para mejorar precisión de Tesseract
                cv.resize(gray, gray, new cv.Size(0,0), 2.0, 2.0, cv.INTER_CUBIC);

                cv.imshow('canvasOutput', gray);
                
                // Limpieza de memoria
                src.delete(); cardMat.delete(); dataMat.delete(); clahe.delete();

                // 4. Ejecutar OCR
                runOCR(gray);

            } catch (err) {
                console.error(err);
                document.getElementById('loader').classList.add('hidden');
                alert("Error al procesar imagen. Intenta con un fondo más oscuro.");
            }
        }

        // Función auxiliar para detectar rectángulo y transformar perspectiva
        function detectAndWarp(src) {
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
            let edges = new cv.Mat();
            cv.Canny(gray, edges, 75, 200);

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            let maxArea = 0;
            let bestContour = null;
            for (let i = 0; i < contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if (area > 30000) {
                    let peri = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                    if (approx.rows === 4 && area > maxArea) {
                        maxArea = area;
                        bestContour = approx;
                    } else { approx.delete(); }
                }
            }

            let cardDst = new cv.Mat();
            let w = 1000, h = 630; // Tamaño objetivo estándar

            if (bestContour) {
                let points = [];
                for(let i=0; i<4; i++) points.push({x: bestContour.intPtr(i)[0], y: bestContour.intPtr(i)[1]});
                // Ordenamiento de puntos para transformación
                points.sort((a,b) => a.y - b.y);
                let top = points.slice(0,2).sort((a,b) => a.x - b.x);
                let bottom = points.slice(2,4).sort((a,b) => a.x - b.x);

                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [top[0].x, top[0].y, top[1].x, top[1].y, bottom[1].x, bottom[1].y, bottom[0].x, bottom[0].y]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, w,0, w,h, 0,h]);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                cv.warpPerspective(src, cardDst, M, new cv.Size(w, h));
                M.delete(); srcTri.delete(); dstTri.delete(); bestContour.delete();
            } else {
                // Fallback si no detecta bordes
                let scale = 1000 / src.cols;
                cv.resize(src, cardDst, new cv.Size(1000, src.rows * scale));
            }
            gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
            return cardDst;
        }

        // --- 2. OCR Y LÓGICA DE NEGOCIO ---
        async function runOCR(matImg) {
            let canvas = document.createElement('canvas');
            cv.imshow(canvas, matImg);
            matImg.delete();

            const worker = await Tesseract.createWorker('spa', 1);
            // Permitimos caracteres especiales temporalmente para no perder info
            await worker.setParameters({ preserve_interword_spaces: '1' });

            const { data: { text } } = await worker.recognize(canvas);
            await worker.terminate();

            const lines = text.split('\n').map(l => l.trim().toUpperCase()).filter(l => l.length > 1);
            
            // --- A. LÓGICA DE NOMBRE (CON VALIDACIÓN) ---
            let validNameParts = [];
            let labelIdx = lines.findIndex(l => l.includes('NOMBRE'));
            let startIdx = (labelIdx !== -1) ? labelIdx + 1 : 0;
            
            // Palabras clave que indican fin del bloque de nombre
            const stopWords = ['DOMICILIO', 'DOMICI', 'CLAVE', 'ELECTORAL', 'MZA', 'LT', 'COL'];

            for (let i = startIdx; i < lines.length; i++) {
                let line = lines[i];
                if (stopWords.some(sw => line.includes(sw)) || /\d/.test(line)) break; // Parada

                let words = line.split(' ');
                
                words.forEach(word => {
                    let clean = word.replace(/[^A-Z]/g, ''); // Limpiar caracteres no alfanuméricos
                    if (clean.length < 3) return; // Ignorar basura muy corta

                    // VALIDACIÓN CON FUSE.JS
                    const results = fuse.search(clean);
                    
                    if (results.length > 0 && results[0].score < 0.4) {
                        // Nombre encontrado en BD o muy similar
                        let bestMatch = results[0].item;
                        validNameParts.push(bestMatch);
                        
                        if (bestMatch === clean) {
                            log(`"${clean}" validado OK`, 'ok');
                            addBadge(clean, 'correct');
                        } else {
                            log(`"${clean}" corregido a "${bestMatch}"`, 'warn');
                            addBadge(`${clean} -> ${bestMatch}`, 'warning');
                        }
                    } else {
                        // Nombre desconocido (No está en BD)
                        log(`"${clean}" desconocido`, 'warn');
                        // Lo marcamos como error visualmente pero no lo agregamos al input final para limpieza
                        addBadge(clean, 'error');
                        
                        // Opcional: Si quieres agregarlo de todas formas, descomenta:
                        // validNameParts.push(clean);
                    }
                });
                
                if (validNameParts.length >= 4) break; // Máximo 4 palabras
            }

            document.getElementById('nombre').value = validNameParts.join(' ');

            // --- B. LÓGICA DE CURP (18 CARACTERES) ---
            let fullText = text.replace(/[\n\r]/g, ' ').replace(/\s+/g, ' ');
            let tokens = fullText.split(' ');
            let finalCurp = "";

            for (let t of tokens) {
                let clean = t.replace(/[^A-Z0-9]/g, '');
                // Patrón CURP: Empieza con 4 letras, longitud mínima 16
                if (/^[A-Z]{4}[0-9O]{6}/.test(clean) && clean.length >= 16) {
                    finalCurp = clean.substring(0, 18);
                    break;
                }
            }

            if (finalCurp) {
                // Corrección de O por 0 e I por 1
                let arr = finalCurp.split('');
                [4,5,6,7,8,9,17].forEach(k => { if(arr[k] === 'O') arr[k] = '0'; if(arr[k] === 'I') arr[k] = '1'; });
                finalCurp = arr.join('');
                document.getElementById('curp-icon').classList.remove('opacity-0');
                log(`CURP detectada: ${finalCurp}`, 'ok');
            }

            document.getElementById('curp').value = finalCurp;
            document.getElementById('loader').classList.add('hidden');
        }

        // Función para agregar etiquetas visuales debajo del input de nombre
        function addBadge(text, type) {
            const div = document.createElement('div');
            div.innerText = text;
            div.className = `tag-${type}`;
            document.getElementById('name-feedback').appendChild(div);
        }
    </script>
</body>
</html>

